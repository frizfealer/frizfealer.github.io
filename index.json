[{"categories":["Topic"],"content":"Introduction A monotonic stack is a stack that keeps its elements in a certain order. For example, an increasing monotonic stack is [x1, x2, …, xn] where x1 \u003c= x2 \u003c= … xn. This means that each element is equal to or larger than the previous one. Monotonic stacks are useful for some problems, e.g. where you need to find the next greater number for each number in an array. For such problems, the key words to look for are next (prev) greater (lesser). For example, given a input array input_array = [4, 3, 7, 5, 6] The next greater number for each element is next_larger = [7, 7, -1, 6, -1] If there is no such value, we set it as -1. For the last element, since there is no value after that, it always set to -1. A brute-force solution uses a nested-for-loop, where the outer loop goes through each element, and the inner loop searches for the next greater element. It’s an O(n^2) solution. However; using a monotonic stack, we only go through the array one time to construct the next larger number and it’s an O(n) solution. ","date":"2023-05-16","objectID":"/monotonic_stack/:1:0","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Topic"],"content":"Algorithm Here are some good references for the algorithm (ref1, ref2). It maintains a monotonic decreasing stack. Let’s say if your input is sorted and all unique, e.g. [1, 3, 4, 5], then the next greater element is always the next one. However, if there are some decreasing orders or duplicated values, we cannot determine the next greater when we saw them. Rather, we put them in the stack, and if later we encounter a greater one. For example input_array = [6, 4, 3, 3, 4, 5, 6] Going from 6 to 3, we see a decreasing order and don’t know the next greater element. We keep them in a monotonic stack. Only when we see the fifth element (4), we know it is the next greater element we are looking for at least for the last element. We then look back into the stack to see if there are other elements also see this as the next greater. In this case, both third and fourth elements are, and they are pop out of the stack. stack = [6, 4, 4] After popping out the “3\"s, we can still maintain the monotonic stack. Next, we encounter five, following the same logic, we pop out the “4\"s, and the stack becomes stack = [6, 5] When seeing 6 in the end, we pop out 5 and the stack becomes stack = [6, 6] Since we maintain this monotonic decrease in the process, whenever we see the violation of monotonic decreasing, we know there we can find the next greater element. For each pop, we record the popped element and the current element as the current element is the next greater element in the stack. ","date":"2023-05-16","objectID":"/monotonic_stack/:2:0","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Topic"],"content":"Leetcode problems (### 496. Next Greater Element I) For reference, the brute-force solution is def nextGreaterElement(nums1: List[int], nums2: List[int]) -\u003e List[int]: num2idx = {i: idx for idx, i in enumerate(nums2)} ans = [] for i in nums1: idx = num2idx[i] next_g = -1 for j in range(idx, len(nums2)): if nums2[j] \u003e i: next_g = nums2[j] break ans.append(next_g) return ans And monotonic-stack solution is def nextGreaterElement(nums1: List[int], nums2: List[int]) -\u003e List[int]: num2ng = {i: -1 for i in nums2} stack = [] ans = [] for i in range(len(nums2)): while stack and nums2[i] \u003e stack[-1]: num2ng[stack.pop()] = nums2[i] stack.append(nums2[i]) for i in nums1: ans.append(num2ng[i]) return ans ","date":"2023-05-16","objectID":"/monotonic_stack/:3:0","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Topic"],"content":"739. Daily Temperatures This is similar to the problem 496. But instead of asking for return the value, it asking return the difference between indices. def dailyTemperatures(T: List[int]) -\u003e List[int]: ans = [0]*len(T) stack = [] for i in range(len(T)): while stack and T[i] \u003e T[stack[-1]]: index = stack.pop() ans[index] = i - index stack.append(i) return ans ","date":"2023-05-16","objectID":"/monotonic_stack/:3:1","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Topic"],"content":"503. Next Greater Element II This is a bit tricky as it set the array to be circular. We can double the array, either physically or virtually to simulate the circular condition in this problem. def nextGreaterElements(nums: List[int]) -\u003e List[int]: ans = [-1]*len(nums) stack = [] for idx in range(len(nums)*2): while stack and nums[stack[-1]] \u003c nums[idx%len(nums)]: ans[stack.pop()] = nums[idx % len(nums)] stack.append(idx % len(nums)) return ans ","date":"2023-05-16","objectID":"/monotonic_stack/:3:2","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Topic"],"content":"907. Sum of Subarray Minimums Before going through this problem, let’s check the two variants Next Less Element Instead of return the next greater element, here we are asked to return the next less. The difference is we maintain a monotonic increasing stack. def nextLessElement(nums): ans = [-1]*len(nums) stack = [] for i in range(len(nums)): while stack and nums[stack[-1]] \u003e nums[i]: ans[stack.pop()] = i stack.append(i) return ans Previous Greater Element Instead of return the next greater element, here we are asked to return the previous greater element. While it is also a valid solution to go through the input backward, the solution below goes through the input forward. This solution is valid because the elements that are less than or equal to the current element in the stack are pop, so we only see the previous greater element. Also, these poped elements are not used anymore because the current elements we pushed will be the previous greater element afterward. def prevGreaterElement(nums): ans = [-1]*len(nums) stack = [] for i in range(len(nums)): while stack and nums[stack[-1]] \u003c= nums[i]: stack.pop() if stack: ans[i] = stack[-1] stack.append(i) return ans With these two variable functions in mind, we can solve the problem 907 easily. Please see this post for the detailed explanation of the algorithm. def sumSubarrayMins(arr: List[int]) -\u003e int: # distance to the left least element left = [i for i in range(1, len(arr)+1)] # distance to the right least elemnt right = [i for i in range(len(arr), 0, -1)] n_stack = [] p_stack = [] for i in range(len(arr)): while n_stack and arr[n_stack[-1]] \u003e arr[i]: idx = n_stack.pop() right[idx] = i - idx n_stack.append(i) while p_stack and arr[p_stack[-1]] \u003e arr[i]: p_stack.pop() if not p_stack: left[i] = i + 1 else: left[i] = i - p_stack[-1] p_stack.append(i) ans = 0 for i in range(len(arr)): ans += left[i]*right[i]*arr[i] ans %= 10**9 + 7 return ans ","date":"2023-05-16","objectID":"/monotonic_stack/:3:3","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Book Note"],"content":"Designing Machine Learning Systems Author: Chip Huyen Publisher: O’Reilly Its a reading note for this book ","date":"2023-03-29","objectID":"/designing-machine-learning-systems/:0:0","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems - Chapter 1","uri":"/designing-machine-learning-systems/"},{"categories":["Book Note"],"content":"Chapter 1. Overview Of Machine Learning Systems ","date":"2023-03-29","objectID":"/designing-machine-learning-systems/:1:0","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems - Chapter 1","uri":"/designing-machine-learning-systems/"},{"categories":["Book Note"],"content":"Outline When to use machine learning Understanding machine learning systems Research vs production ML system vs traditional software system ","date":"2023-03-29","objectID":"/designing-machine-learning-systems/:1:1","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems - Chapter 1","uri":"/designing-machine-learning-systems/"},{"categories":["Book Note"],"content":"Recall What are the different components of ML systems? possible answer infrastructure, data, feature (engineering), ML algorithm, evaluation metrics, deployment, and monitoring continuous updates (CI/CD). What does MLOps mean? possible answer MLOps comes from DevOps, short for development and operations. To operate something means bringing it into production, which includes deploying, monitoring, and maintaining. What does a machine learning solution do? possible answer An ML system learns complex patterns from data that can be used to make predictions on unseen data. What’s the difference between a traditional algorithm and an ML algorithm? possible answer In the traditional algorithm, you code logic/patterns, whereas the ML algorithm, it learns logic/patterns from data. What are the cases where ML algorithms excel? possible answer Wrong predictions are cheap, the ML system will be used a lot (at scale) because the development cost is high. Without ML you cannot do the task. What are some customer ML applications? possible answer Recommendation, searching, face recognition. Text autocompletion The majority of ML use cases are still in the enterprise world. What are some enterprise ML applications? possible answer Fraud detection, price/cost optimization, demand forecasting, customer acquisition, churn prediction, and internal IT ticket routing predictions, brand monitoring. What are the differences between research ML and production ML? Can answers from Requirements, Computational priority, data. possible answer Research Research Production Requirements Achieve SOTA on public benchmark Different stakeholders have different requirements Computational priority Fast training, high throughput Fast inference, low latency Data Static, clean Changing, dirty, need annotation. Others Might need fairness, explainability What are some criticisms of ML leaderboards? possible answer Hard steps (collecting, cleaning, labeling) are already done for you. Recently data-centric ML, advocated by Andrew Ng has been a buzz term. when you have multiple teams testing on the same hold-out test set, a model can do better than the rest just by chance. This is like you are reporting your evaluation number on the validation set (ref). What does p99 mean in latency measurement? possible answer p99 means the 99-percentile of your service latency. It is useful to check this number because it includes the most distribution of service latency. In terms of system design, how is the ML system different from the traditional software system? possible answer In traditional SWE, code, and data are separated. Whereas in ML, code, data, and artifacts (model, features) are intertwined. In traditional SWE you versioned code. Whereas in ML, you might also version the data, and models. Large models with high complexity cause long computation times. Monitoring ML systems is harder because of the model’s complexity. Cannot run parallelly for each component (model, features). ","date":"2023-03-29","objectID":"/designing-machine-learning-systems/:1:2","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems - Chapter 1","uri":"/designing-machine-learning-systems/"},{"categories":["Book Note"],"content":"SUMMARY Machine learning (ML) systems can solve problems with complex patterns that are difficult to code. However, this comes at the price of a more complex data processing, service computation, and continuous integration/continuous deployment (MLOps). This chapter also covers common ML system use cases for both customers and enterprises. Finally, the chapter discusses the differences between ML in research and in production.** ","date":"2023-03-29","objectID":"/designing-machine-learning-systems/:1:3","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems - Chapter 1","uri":"/designing-machine-learning-systems/"}]