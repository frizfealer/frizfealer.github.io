[{"categories":["Book Note"],"content":"prodigal: 一擲千金地花費所有的 ","date":"2023-09-20","objectID":"/the_prodigal_god/:0:0","tags":["Christian belief","Timothy Keller"],"title":"摘要：一擲千金的上帝","uri":"/the_prodigal_god/"},{"categories":["Book Note"],"content":"介紹 這本書是對路加福音15章 1-3, 11-32節，耶穌所說的寓言的解說 ","date":"2023-09-20","objectID":"/the_prodigal_god/:1:0","tags":["Christian belief","Timothy Keller"],"title":"摘要：一擲千金的上帝","uri":"/the_prodigal_god/"},{"categories":["Book Note"],"content":"第一章：角色介紹 這個寓言提到父親和兩個兒子，對應兩種人 父親：比喻為上帝。 老大：遵守律法，道德。對應於世界上的保守主義，道德主義 老二：追尋個人自由。對應於世界上的自由主義，相對主義 耶穌站在哪一邊呢？耶穌不站在任何一邊。基督信仰跟道德主義其實不相關。 在當時，耶穌吸引的往往是老二類型的人。在現代，基督信仰吸引的是老大類型的人，這值得我們深思。 ","date":"2023-09-20","objectID":"/the_prodigal_god/:2:0","tags":["Christian belief","Timothy Keller"],"title":"摘要：一擲千金的上帝","uri":"/the_prodigal_god/"},{"categories":["Book Note"],"content":"第二章：故事大意 詳細提到兩個兒子和父親的態度 小兒子的無禮無情 父親的包容 小兒子的計畫 父親的接納 大兒子的無禮 父親的回應 ","date":"2023-09-20","objectID":"/the_prodigal_god/:3:0","tags":["Christian belief","Timothy Keller"],"title":"摘要：一擲千金的上帝","uri":"/the_prodigal_god/"},{"categories":["Book Note"],"content":"第三章：動機 兩個兒子雖然表面上行為不同，但其實他們的目標動機類似 他們的目標動機都是想得到父親的財產。小兒子直接開口要，大兒子則是遵守規則，預期因此父親要給他財產。 不是因為他的罪造成了他與服親的阻隔，而是因為他對自己優良品德的驕傲 大兒子的罪，在於想要達到道德要求去要求上帝，而不是順服。在於不是討父親的喜悅，而是在意自己的得失。 罪不只是破壞規則，它也是只把自己放到上帝的位置上來作救主，主宰和審判者 耶穌的福音不屬於任何一邊。如同寓言的父親對兒子們的愛，即使兩個人都錯了，仍然願意接納他們。 ","date":"2023-09-20","objectID":"/the_prodigal_god/:4:0","tags":["Christian belief","Timothy Keller"],"title":"摘要：一擲千金的上帝","uri":"/the_prodigal_god/"},{"categories":["Book Note"],"content":"第四章：迷失 屬靈的迷失 大兒子的迷失包括憤怒，和對其他道德沒他好的人的優越感。 大兒子的迷失也包括對神關係的奴役與虛空感。他對父親的關係不是出於愛，而是老闆員工關係。他遵守父親的指令是因為害怕。他不能體會與父親之間的愛，因此產生虛空感。 大兒子類型的貶低其他人，過度標榜道德，引起其他人的排斥基督信仰，這點值得注意。 ","date":"2023-09-20","objectID":"/the_prodigal_god/:5:0","tags":["Christian belief","Timothy Keller"],"title":"摘要：一擲千金的上帝","uri":"/the_prodigal_god/"},{"categories":["Book Note"],"content":"第五章：真正的大兒子 故事中父親不論對大兒子還是小兒子，都主動表達了無條件的愛。 若不是上帝主動尋找我們，我們永遠也找不到祂，祂會以非常不同的方式來尋找每一個人 我們需要學習為自己的罪（犯錯）和義行下的罪悔改。例如大兒子道德上沒有錯誤，但底層的動機是想要滿足自己的驕傲，想要主宰一切，不願意順服。 在路加福音其他的寓言（失錢，失羊）裡，迷失的東西都有人努力的去尋找。唯獨這個故事沒有。情理上，大兒子應該是那個努力尋找他弟弟的人。 耶穌正如同一個真正的大兒子，願意付出代價找回失散的我們（小兒子）。 耶穌基督擁有世上一切的權柄，祂看見我們被許多事物奴役，而我們卻以為它們會給我們自由，所以祂放棄自己的榮耀而成為一名僕人：祂放棄自己本性中的無限和廣大，並以自己的生命為代價，為我們買下唯一可以讓我們心安歇的地方，那就是天父的家 了解耶穌廣大的愛，也因此調和我們心中大兒子和小兒子的矛盾。 我們的責任和歡喜，雖然曾經互相對立。但因見過祂的美麗，已經連和不再分離。 ","date":"2023-09-20","objectID":"/the_prodigal_god/:6:0","tags":["Christian belief","Timothy Keller"],"title":"摘要：一擲千金的上帝","uri":"/the_prodigal_god/"},{"categories":["Book Note"],"content":"第六章 回家的渴望 整個聖經的主軸之一是回家：我們想要回到上帝當初創造的樂園。舊約中有許多例子：雅各被迫逃離家後想要回去，約瑟被賣到埃及後想要回去等。 這個故事的小兒子也是，雖然曾經迷失在外，後來發現，自己最渴望的是回家。 聖經的信息指出，全人類就是一群想要歸家的流浪者，因此這個迷失兒子的比喻，和我們每一個人有關 我們無法回家，一個原因是我們內心的罪：我們沈迷於自私和驕傲。耶穌來到世上，就是想要救我們脫離罪和死亡。 ","date":"2023-09-20","objectID":"/the_prodigal_god/:7:0","tags":["Christian belief","Timothy Keller"],"title":"摘要：一擲千金的上帝","uri":"/the_prodigal_god/"},{"categories":["Book Note"],"content":"緣由 最近看了亞馬遜推薦的，關於心理治療方面的書：\"蛤蟆先生去看心理師\" (Counselling for Toads: A Psychological Adventure. )。 這是一本有趣的小書，主角是隻蛤蟆，以他和他的心理師蒼鷺之間的心理治療故事。 ","date":"2023-07-05","objectID":"/counselling_for_toads/:1:0","tags":["Psychology"],"title":"摘要：蛤蟆先生去看心理師","uri":"/counselling_for_toads/"},{"categories":["Book Note"],"content":"摘要 根據外部資料，這本書裡面的心理治療方式稱為溝通分析(Transactional Analysis, TA)。書中提到有幾個概念。 心理諮詢是一個自發的過程，諮詢師和當事人都必須出於自願，也可以說諮詢是和當事人是一起走這段療癒過程的合作夥伴。 TA把人分成三種狀態，孩子，父母和成人狀態。狀態是指人的行為和感覺。 孩子狀態是活得如同孩子一般，對外在環境作出情緒反應（自然情緒反應）或是被逼迫適應的情緒反應，依賴，不用負責。 父母狀態是活得如同父母一般，運用從父母學到的觀念，教育，批判別人，並給他們懲罰。 成人狀態既不像孩子活在過去的情緒，也不像父母狀態活在過去的觀念。而是活在當下，根據情況作出情緒觀念的調整和學習。 TA提到四種心理地位 我好，你也好 我好，你不好 我不好，你好 我不好，你也不好 這裡的好和不好是指正面和負面的感覺。選擇我不好，你好的，通常是比較自卑的，也常常會玩受害者遊戲，把自己放在受害者的角色。 選擇我好，你不好的則相反。我好，你也好在TA裡面是最好的心理地位。這種狀態能看出別人和自己的好，也能同理別人和自己的不好。 ","date":"2023-07-05","objectID":"/counselling_for_toads/:2:0","tags":["Psychology"],"title":"摘要：蛤蟆先生去看心理師","uri":"/counselling_for_toads/"},{"categories":["Book Note"],"content":"書中摘要 \"歸根究底，我們的感覺是自己選擇的，我們選擇要生氣或悲傷。\" \"責怪別人是在兒童狀態下所做的，那似乎也是你最喜歡的狀態\"...\"除了怪罪，負起責任聽起來如何？\" ","date":"2023-07-05","objectID":"/counselling_for_toads/:3:0","tags":["Psychology"],"title":"摘要：蛤蟆先生去看心理師","uri":"/counselling_for_toads/"},{"categories":["Book Note"],"content":"結語 這是一本輕巧有趣的書。無論是心理還是身體上，療癒，都是從自己起始。我們每個人都應該為自己負責，也有能力為自己負責。 療癒的第一步是覺察，心理諮詢是一個很有效的覺察工具。當我們能夠以旁觀者的角度回顧自己的情緒(觀)，我們就可以跳出以前的行為模式。 接下來，我們可以選擇放下過去，專注當下。 ","date":"2023-07-05","objectID":"/counselling_for_toads/:4:0","tags":["Psychology"],"title":"摘要：蛤蟆先生去看心理師","uri":"/counselling_for_toads/"},{"categories":["Book Note"],"content":"緣由 最近在看楊定一博士所著的“時間的陷阱”，裡面對時間的形成有深刻的論敘。其中特別提到：空間是時間的延伸。 對我來說，這不是個好理解的概念，因此花了些時間想了這句話底層的邏輯。這篇文章主要是把我想到的一些看法記錄在這。 ","date":"2023-06-19","objectID":"/what_is_time/:1:0","tags":["Metaphysics","”時間的陷阱“讀後感"],"title":"時間是什麼？","uri":"/what_is_time/"},{"categories":["Book Note"],"content":"時間是什麼 “時間的陷阱”一書提到：時間由比較而來。具體來說，是 比較關聯的事件 來的。我們人類學會觀察天上星體。日升日落，理解為一天的時間過了。春夏秋冬，理解為一年過了。 隨著文明發展，我們定義了全球通用的時間，可以用更精確的方法表示。 ","date":"2023-06-19","objectID":"/what_is_time/:2:0","tags":["Metaphysics","”時間的陷阱“讀後感"],"title":"時間是什麼？","uri":"/what_is_time/"},{"categories":["Book Note"],"content":"時間和空間的關聯：我的看法 如何說空間是時間的延伸呢？以下嘗試用一些例子說明。 一個例子是我書桌上的杯子和餐桌上的杯子，這兩者是在不同位置。我怎麼知道他們在不同位置？ 可以透過測量，而沒有時間就沒有測量的概念。 時間 -\u003e 測量 -\u003e 空間 或是說空間是比較加上記憶(也是時間形成的必要條件)延伸的。 比較+記憶+關聯 -\u003e 時間，空間 我覺得這兩個都說得通，不是很明確空間是由時間而來，有可能是一起出現。 ","date":"2023-06-19","objectID":"/what_is_time/:3:0","tags":["Metaphysics","”時間的陷阱“讀後感"],"title":"時間是什麼？","uri":"/what_is_time/"},{"categories":["Book Note"],"content":"額外的思考實驗 設想如果沒有時間，過去現在未來都同時發生(All at once) 你隨時可以看到在在公司的我和在家的我，所以你沒辦法區分這是兩的不同的地方。 同理可證任何地方都沒辦法區分。因此沒有時間，也沒有了空間 ","date":"2023-06-19","objectID":"/what_is_time/:3:1","tags":["Metaphysics","”時間的陷阱“讀後感"],"title":"時間是什麼？","uri":"/what_is_time/"},{"categories":["Book Note"],"content":"雜想：頭腦的能力 “時間的陷阱”一書提到：我們的頭腦，憑藉著記憶，比較，關聯，可以推演出時間，或著空間。 沒有記憶，比較，關聯，我們就沒辦法理解這個世界。 這裡我聯想到道德經第二章：“故有無相生，難易相成，長短相形，高下相傾，音聲相和，前後相隨” :沒有高就沒有低，沒有長就沒有短，二元對立的比較是我們理解這個世界的方法。 ","date":"2023-06-19","objectID":"/what_is_time/:4:0","tags":["Metaphysics","”時間的陷阱“讀後感"],"title":"時間是什麼？","uri":"/what_is_time/"},{"categories":["Article"],"content":"Introduction A monotonic stack is a stack that keeps its elements in a certain order. For example, an increasing monotonic stack is [x1, x2, …, xn] where x1 \u003c= x2 \u003c= … xn. This means that each element is equal to or larger than the previous one. Monotonic stacks are useful for some problems, e.g. where you need to find the next greater number for each number in an array. For such problems, the key words to look for are next (prev) greater (lesser). For example, given a input array input_array = [4, 3, 7, 5, 6] The next greater number for each element is next_larger = [7, 7, -1, 6, -1] If there is no such value, we set it as -1. For the last element, since there is no value after that, it always set to -1. A brute-force solution uses a nested-for-loop, where the outer loop goes through each element, and the inner loop searches for the next greater element. It’s an O(n^2) solution. However; using a monotonic stack, we only go through the array one time to construct the next larger number and it’s an O(n) solution. ","date":"2023-05-16","objectID":"/monotonic_stack/:1:0","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Article"],"content":"Algorithm Here are some good references for the algorithm (ref1, ref2). It maintains a monotonic decreasing stack. Let’s say if your input is sorted and all unique, e.g. [1, 3, 4, 5], then the next greater element is always the next one. However, if there are some decreasing orders or duplicated values, we cannot determine the next greater when we saw them. Rather, we put them in the stack, and if later we encounter a greater one. For example input_array = [6, 4, 3, 3, 4, 5, 6] Going from 6 to 3, we see a decreasing order and don’t know the next greater element. We keep them in a monotonic stack. Only when we see the fifth element (4), we know it is the next greater element we are looking for at least for the last element. We then look back into the stack to see if there are other elements also see this as the next greater. In this case, both third and fourth elements are, and they are pop out of the stack. stack = [6, 4, 4] After popping out the “3\"s, we can still maintain the monotonic stack. Next, we encounter five, following the same logic, we pop out the “4\"s, and the stack becomes stack = [6, 5] When seeing 6 in the end, we pop out 5 and the stack becomes stack = [6, 6] Since we maintain this monotonic decrease in the process, whenever we see the violation of monotonic decreasing, we know there we can find the next greater element. For each pop, we record the popped element and the current element as the current element is the next greater element in the stack. ","date":"2023-05-16","objectID":"/monotonic_stack/:2:0","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Article"],"content":"Leetcode problems (### 496. Next Greater Element I) For reference, the brute-force solution is def nextGreaterElement(nums1: List[int], nums2: List[int]) -\u003e List[int]: num2idx = {i: idx for idx, i in enumerate(nums2)} ans = [] for i in nums1: idx = num2idx[i] next_g = -1 for j in range(idx, len(nums2)): if nums2[j] \u003e i: next_g = nums2[j] break ans.append(next_g) return ans And monotonic-stack solution is def nextGreaterElement(nums1: List[int], nums2: List[int]) -\u003e List[int]: num2ng = {i: -1 for i in nums2} stack = [] ans = [] for i in range(len(nums2)): while stack and nums2[i] \u003e stack[-1]: num2ng[stack.pop()] = nums2[i] stack.append(nums2[i]) for i in nums1: ans.append(num2ng[i]) return ans ","date":"2023-05-16","objectID":"/monotonic_stack/:3:0","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Article"],"content":"739. Daily Temperatures This is similar to the problem 496. But instead of asking for return the value, it asking return the difference between indices. def dailyTemperatures(T: List[int]) -\u003e List[int]: ans = [0]*len(T) stack = [] for i in range(len(T)): while stack and T[i] \u003e T[stack[-1]]: index = stack.pop() ans[index] = i - index stack.append(i) return ans ","date":"2023-05-16","objectID":"/monotonic_stack/:3:1","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Article"],"content":"503. Next Greater Element II This is a bit tricky as it set the array to be circular. We can double the array, either physically or virtually to simulate the circular condition in this problem. def nextGreaterElements(nums: List[int]) -\u003e List[int]: ans = [-1]*len(nums) stack = [] for idx in range(len(nums)*2): while stack and nums[stack[-1]] \u003c nums[idx%len(nums)]: ans[stack.pop()] = nums[idx % len(nums)] stack.append(idx % len(nums)) return ans ","date":"2023-05-16","objectID":"/monotonic_stack/:3:2","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Article"],"content":"907. Sum of Subarray Minimums Before going through this problem, let’s check the two variants Next Less Element Instead of return the next greater element, here we are asked to return the next less. The difference is we maintain a monotonic increasing stack. def nextLessElement(nums): ans = [-1]*len(nums) stack = [] for i in range(len(nums)): while stack and nums[stack[-1]] \u003e nums[i]: ans[stack.pop()] = i stack.append(i) return ans Previous Greater Element Instead of return the next greater element, here we are asked to return the previous greater element. While it is also a valid solution to go through the input backward, the solution below goes through the input forward. This solution is valid because the elements that are less than or equal to the current element in the stack are pop, so we only see the previous greater element. Also, these poped elements are not used anymore because the current elements we pushed will be the previous greater element afterward. def prevGreaterElement(nums): ans = [-1]*len(nums) stack = [] for i in range(len(nums)): while stack and nums[stack[-1]] \u003c= nums[i]: stack.pop() if stack: ans[i] = stack[-1] stack.append(i) return ans With these two variable functions in mind, we can solve the problem 907 easily. Please see this post for the detailed explanation of the algorithm. def sumSubarrayMins(arr: List[int]) -\u003e int: # distance to the left least element left = [i for i in range(1, len(arr)+1)] # distance to the right least elemnt right = [i for i in range(len(arr), 0, -1)] n_stack = [] p_stack = [] for i in range(len(arr)): while n_stack and arr[n_stack[-1]] \u003e arr[i]: idx = n_stack.pop() right[idx] = i - idx n_stack.append(i) while p_stack and arr[p_stack[-1]] \u003e arr[i]: p_stack.pop() if not p_stack: left[i] = i + 1 else: left[i] = i - p_stack[-1] p_stack.append(i) ans = 0 for i in range(len(arr)): ans += left[i]*right[i]*arr[i] ans %= 10**9 + 7 return ans ","date":"2023-05-16","objectID":"/monotonic_stack/:3:3","tags":["Algorithm/Data Structure","Python","stack"],"title":"Monotonic Stack","uri":"/monotonic_stack/"},{"categories":["Book Note"],"content":"Book Info Title: Designing Machine Learning Systems Author: Chip Huyen Publisher: O’Reilly This is a reading note for this book. ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:1:0","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Chapter 1. Overview Of Machine Learning Systems ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:2:0","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Outline When to use machine learning Understanding machine learning systems Research vs production ML system vs traditional software system ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:2:1","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Recall What are the different components of ML systems? What does MLOps mean? What does a machine learning solution do? What’s the difference between a traditional algorithm and an ML algorithm? What are the cases where ML algorithms excel? What are some customer ML applications? The majority of ML use cases are still in the enterprise world. What are some enterprise ML applications? What are the differences between research ML and production ML? Can answers from Requirements, Computational priority, data. What are some criticisms of ML leaderboards? What does p99 mean in latency measurement? In terms of system design, how is the ML system different from the traditional software system? ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:2:2","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Possible Answers to Recall answers What are the different components of ML systems? A: infrastructure, data, feature (engineering), ML algorithm, evaluation metrics, deployment, and monitoring continuous updates (CI/CD). What does MLOps mean? A: MLOps comes from DevOps, short for development and operations. To operate something means bringing it into production, which includes deploying, monitoring, and maintaining. What does a machine learning solution do? A: An ML system learns complex patterns from data that can be used to make predictions on unseen data. What’s the difference between a traditional algorithm and an ML algorithm? A: In the traditional algorithm, you code logic/patterns, whereas the ML algorithm, it learns logic/patterns from data. What are the cases where ML algorithms excel? A: Wrong predictions are cheap, the ML system will be used a lot (at scale) because the development cost is high. Without ML you cannot do the task. What are some customer ML applications? A: Recommendation, searching, face recognition. Text autocompletion. The majority of ML use cases are still in the enterprise world. What are some enterprise ML applications? A: Fraud detection, price/cost optimization, demand forecasting, customer acquisition, churn prediction, and internal IT ticket routing predictions, brand monitoring. What are the differences between research ML and production ML? Can answers from Requirements, Computational priority, data. A: Research Research Production Requirements Achieve SOTA on public benchmark Different stakeholders have different requirements Computational priority Fast training, high throughput Fast inference, low latency Data Static, clean Changing, dirty, need annotation. Others Might need fairness, explainability What are some criticisms of ML leaderboards? A: Hard steps (collecting, cleaning, labeling) are already done for you. Recently data-centric ML, advocated by Andrew Ng has been a buzz term. when you have multiple teams testing on the same hold-out test set, a model can do better than the rest just by chance. This is like you are reporting your evaluation number on the validation set (ref). What does p99 mean in latency measurement? A: p99 means the 99-percentile of your service latency. It is useful to check this number because it includes the most distribution of service latency. In terms of system design, how is the ML system different from the traditional software system? A: In traditional SWE, code, and data are separated. Whereas in ML, code, data, and artifacts (model, features) are intertwined. In traditional SWE you versioned code. Whereas in ML, you might also version the data, and models. Large models with high complexity cause long computation times. Monitoring ML systems is harder because of the model’s complexity. Cannot run parallelly for each component (model, features). ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:2:3","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Summary Machine learning (ML) systems can solve problems with complex patterns that are difficult to code. However, this comes at the price of a more complex data processing, service computation, and continuous integration/continuous deployment (MLOps). This chapter also covers common ML system use cases for both customers and enterprises. Finally, the chapter discusses the differences between ML in research and in production. ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:2:4","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Chapter 2. Introduction to Machine Learning Systems Design ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:3:0","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Outline Business and ML Objective Requirements of ML systems The iterative development process of ML systems. Framing ML problems Mind versus data ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:3:1","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Good reference applied-ml: curated papers, articles, and blogs on data science \u0026 machine learning in production ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:3:2","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Recall How to align Business and ML Objectives? What are the four requirements of ML systems and what do they mean? ML system development process involves many steps. What are they? What are the different types of ML tasks? How do you formulate multi-label ML tasks? Whats the design strategy when you want to optimize multiple objectives of a ML algorithm? ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:3:3","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Possible Answers to Recall answers How to align Business and ML Objectives? A: Can be done in the following steps. Know what metrics business care about. e.g. sales: conversion rate. Tie the performance of an ML system to the overall business performance. You may need to conduct A/B tests to know how ML metrics influence business metrics. If the metrics of ML system and of the business are not aligned enough. Define custom ML metrics for better alignment, e.g. Netflix has take-rate: the number of quality plays divided by the number of recommendations a user sees. What are the four requirements of ML systems and what do they mean? A: Reliability: The system should continue to perform the correct function at the desired level of performance even in the face of adversity. how do you measure the correctness of your model? (Using new test set, monitoring some metrics). Scalability System Growth Solutions parameters in models distributed training traffic volume of service auto-scaling many ML models experiment and data version tracking Maintainability: Code should be documented. Code, data, and artifacts should be versioned. ML engineers, subject matter experts, and software engineers can work together easily. Adaptability: the system should be adaptive to business requirement changes and data distribution changes. ML system development process involves many steps. What are they? A: Project scoping, data engineering, model development, service deployment, monitoring and continuous learning, and business analysis. What are the different types of ML tasks? A: Regression, classification(binary/multi-class (could be low or high cardinality), multi-label), recommendation. How do you formulate multi-label ML tasks? A: You can formulate this into multiple binary classification problems. You can also formulate it as a multi-class classification. Whats the design strategy when you want to optimize multiple objectives of a ML algorithm? A: You can have the objective function to be $$ obj_{all} = \\alpha obj_1 + \\beta obj_2 + \\dots $$ if you want to systematically select alpha and beta, you can use pareto frontier. Any solution on the frontier cannot be improved in any of the objectives without degrading at least one of the other objectives. multi-objective optimization from Wiki. However the book suggested another approach, that is having a model for each objective function. And you only tune each models output score when you want to weigh differently , $$ score_{all} = \\alpha score_1 + \\beta score_2 + \\dots $$ Therefore, you don’t need to re-train the model because of different alpha and beta. This idea is like boosting! ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:3:4","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"},{"categories":["Book Note"],"content":"Summary The objective of machine learning (ML) systems should be driven by business needs since these systems are designed to serve business goals. ML systems should also have the same qualities as other software systems, such as reliability, scalability, maintainability, and adaptability (although the methods and metrics for achieving and measuring these qualities may differ from traditional software systems). Regression and classification are typical ML tasks. The book recommends training separate models for each objective function when we have multiple objectives to optimize and then combining their outputs with different weights. Finally, the book discusses some of the opinions of prominent AI experts on the trade-off between model and data. ","date":"2023-03-29","objectID":"/designing_machine_learning_systems_1/:3:5","tags":["Machine Learning","System Design","Software Engineering"],"title":"Designing Machine Learning Systems (1)","uri":"/designing_machine_learning_systems_1/"}]